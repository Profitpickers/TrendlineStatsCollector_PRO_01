//+------------------------------------------------------------------+
//| TrendlineStatsCollector_PRO_01_v1.07.mq5                         |
//| Copyright 2025, ProfitPickers - vitoiacobellis.it                |
//| https://www.vitoiacobellis.it                                    |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, ProfitPickers - vitoiacobellis.it"
#property link      "https://www.vitoiacobellis.it"
#property version   "1.06"
#property strict
#property description "EA di analisi trendline macro-micro, delta e dashboard statistica."

#include <Trade/Trade.mqh>
// #include <stdlib.mqh>


#include "../Include/CTradeDecisionManager.mqh"
#include "../Include/CTradeExecutor.mqh"
#include "../Include/CVolumeManager.mqh"
#include "../Include/AuditCheck.mqh"
#include "../Include/CTrendlineAnalyzer.mqh"


#include <ChartObjects/ChartObjectsLines.mqh>
#include "../Include/CTrackCounterDrawer.mqh"
#include "../Include/CStrategyParamsManager.mqh"
#include "../Include/CAuditCheck.mqh"
#include "../Include/AuditParamsCheck.mqh"
#include "../Include/ParamConverters.mqh"

//==============================//
// ORIGINE DATI E TRENDLINE     //
//==============================//
input group "bypass_filter per abilitare audit anche in Strategy Tester"
input bool bypass_filter = true;  // üîì Esegui Audit anche nel Strategy Tester


//==============================//
// ORIGINE DATI E TRENDLINE     //
//==============================//
input group "ORIGINE DATI E TRENDLINE"
input ENUM_TLBaseCalc TL_CalcBase = TL_CLOSE;
input int TL_MA_Period = 14;

input group "Trendline Settings"
input int micro_bars = 10;
input int macro_bars = 50;
input int extra_bars = 300;
input int count_window = 20;

//==============================//
//      MODALITA' LOG           //
//==============================//
input bool debug_strategy = true; // Attiva o disattiva la modalit√† di log [DEBUG]



//==============================//
// FILTRI E NORMALIZZAZIONE     //
//==============================//
input group "Filtri Volatilit√† e Volume"
input bool enable_auto_normalizer = true;
input double min_volatility_pips = 50;
input double min_volume_tick_avg = 100;


//==============================//
// ‚öôÔ∏è SOGLIE INDEX RENDLINE   I //
//==============================//
input group "Soglie Globali - Regolazione sensibilit√† strategie"
input double REMOVED_MIN_INDEX_BUY  = 1000.0;   // Soglia minima INDEX per BUY
input double REMOVED_MAX_INDEX_SELL = -1000.0;  // Soglia massima INDEX per SELL



//==============================//
// ‚öôÔ∏è SOGLIE GLOBALI - DELTA / ANGOLI //
//==============================//
input group "Soglie Globali - Regolazione sensibilit√† strategie"

// Soglia di compressione tra micro e macro trendline (Strategia 1)
input double delta_mm_s1 = 0.5;     // Diff. ang. max ¬∞ micro VS macro TL attiva compressione

// Soglia di compressione tra macro e extra trendline (Strategia 1)
input double delta_me_s1 = 0.5;     // Diff. ang. max ¬∞ macro VS extra TL attiva compressione


// Soglia di compressione tra extra e micro trendline (Strategia 1)
input double delta_em_s1 = 0.5;     // Diff. ang. max ¬∞ extra VS micro TL attiva compressione


// Soglia pendenza trendline extra per attivazione strategia 3
input double angle_thresh_ext = 25.0;   // Pendenza min ¬∞ trendline EXTRA attiva condizioni retracement

// Soglia pendenza combinata micro e macro per strategia 3
input double angle_thresh_micmac = 15.0; // Pendenza min ¬∞ richiesta a micro e macro TL per rilevare trend diretto

// Delta minimo tra macro ed extra per validare lo scenario di ritracciamento (Strategia 3)
input double delta_min_retracement = 0.3;  // Differenza angolare minima ¬∞ macro Vs extra attiva retracement

// Distanza massima tra prezzo e TL extra per ritracciamento valido (Strategia 3)
input double max_dist_retracement = 200.0; // Massima distanza in punti tra prezzo e TL extra x evento significativo


input double s1_equity_tp_buy = 10.0;
input double s2_equity_tp_buy = 10.0;
input double s3_equity_tp_buy = 10.0;

input int s1_max_positions_buy = 1;
input int s2_max_positions_buy = 1;
input int s3_max_positions_buy = 1;

input int s1_min_spacing_buy = 10;
input int s2_min_spacing_buy = 10;
input int s3_min_spacing_buy = 10;




//==============================//
// üéØ STRATEGIA 1
//==============================//
input group "üéØ Strategia 1 - Parametri Generali üéØ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
input bool     enable_strategy_1           = true;        // Attiva o disattiva la Strategia 1 (logica su soglie positive)
input bool     invert_strategy_1           = false;       // Inverte la logica BUY/SELL per test contrarian
input int      magic_strategy_1            = 110001;      // Numero magico univoco per la Strategia 1
input int      sl_pips_s1                  = 40;          // Stop Loss in pips per ogni ordine S1
input int      tp_pips_s1                  = 60;          // Take Profit in pips per ogni ordine S1
input int      trendline_bars_s1           = 20;          // Numero barre da considerare per costruzione trendline S1
input double   equity_tp_s1                = 10.0;        // Profitto cumulativo per chiusura ordini di S1
input int      max_positions_s1            = 3;           // Numero massimo di posizioni contemporanee per S1
input double   min_spacing_s1              = 5.0;         // Spaziatura minima tra ordini S1
input double   trail_pips_s1               = 10.0;        // Trailing Stop in pips per ordini di S1

//------------------------------//
// üü¢ Strategia 1 - BUY Trigger
//------------------------------//
input group "üü¢ Strategia 1 - BUY Settings"
input bool     s1_use_buy                  = true;        // Abilita il lato BUY per Strategia 1
input double   angle_thresh_extra_s1_buy   = 30.0;        // Pendenza minima positiva della trendline EXTRA
input double   angle_thresh_macro_s1_buy   = 25.0;        // Pendenza minima positiva della trendline MACRO
input double   angle_thresh_micro_s1_buy   = 20.0;        // Pendenza minima positiva della trendline MICRO
input double   price_dist_extra_s1_buy     = 100.0;       // Distanza minima tra prezzo e trendline EXTRA (BUY)
input double   delta_tl_s1_buy             = 10.0;        // Differenza angolare tra le 3 TL per validazione BUY
input double   index_s1_buy                = 0.8;         // Valore minimo dell‚Äôindice combinato per attivare BUY 

//------------------------------//
// üî¥ Strategia 1 - SELL Trigger
//------------------------------//
input group "üî¥ Strategia 1 - SELL Settings"
input bool     s1_use_sell                 = true;        // Abilita il lato SELL per Strategia 1
input double   angle_thresh_extra_s1_sell  = -30.0;       // Pendenza minima negativa della trendline EXTRA
input double   angle_thresh_macro_s1_sell  = -25.0;       // Pendenza minima negativa della trendline MACRO
input double   angle_thresh_micro_s1_sell  = -20.0;       // Pendenza minima negativa della trendline MICRO
input double   price_dist_extra_s1_sell    = 100.0;       // Distanza minima tra prezzo e trendline EXTRA (SELL)
input double   delta_tl_s1_sell            = 10.0;        // Differenza angolare tra le 3 TL per validazione SELL
input double   index_s1_sell               = 0.8;         // Valore minimo dell‚Äôindice combinato per attivare SELL



//==============================//
// üéØ STRATEGIA 2
//==============================//
input group "üéØ Strategia 2 - Parametri Generali üéØ 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2"
input bool   enable_strategy_2           = true;        // Attiva o disattiva la Strategia 2 (logica su soglie negative)
input bool   invert_strategy_2           = false;       // Inverte la logica BUY/SELL per test contrarian
input int    magic_strategy_2            = 110002;      // Numero magico univoco per la Strategia 2
input int    sl_pips_s2                  = 40;          // Stop Loss in pips per ogni ordine S2
input int    tp_pips_s2                  = 60;          // Take Profit in pips per ogni ordine S2
input int    trendline_bars_s2           = 20;          // Numero barre da considerare per costruzione trendline S2
input double equity_tp_s2                = 10.0;        // Profitto cumulativo per chiusura ordini di S2
input int    max_positions_s2            = 3;           // Numero massimo di posizioni contemporanee per S2
input double min_spacing_s2              = 5.0;         // Spaziatura minima tra ordini S2
input double trail_pips_s2               = 10.0;        // Trailing Stop in pips per ordini di S2

//------------------------------//
// üü¢ Strategia 2 - BUY Trigger
//------------------------------//
input group "üü¢ Strategia 2 - BUY Settings"
input bool   s2_use_buy                  = true;        // Abilita il lato BUY per Strategia 2
input double angle_thresh_extra_s2_buy  = 30.0;         // Pendenza minima positiva della trendline EXTRA
input double angle_thresh_macro_s2_buy  = 25.0;         // Pendenza minima positiva della trendline MACRO
input double angle_thresh_micro_s2_buy  = 20.0;         // Pendenza minima positiva della trendline MICRO
input double price_dist_extra_s2_buy    = 100.0;        // Distanza minima tra prezzo e trendline EXTRA (BUY)
input double delta_tl_s2_buy            = 10.0;         // Differenza angolare tra le 3 TL per validazione BUY
input double index_s2_buy               = 0.8;          // Valore minimo dell‚Äôindice combinato per attivare BUY 

//------------------------------//
// üî¥ Strategia 2 - SELL Trigger
//------------------------------//
input group "üî¥ Strategia 2 - SELL Settings"
input bool   s2_use_sell                 = true;        // Abilita il lato SELL per Strategia 2
input double angle_thresh_extra_s2_sell = -30.0;        // Pendenza minima negativa della trendline EXTRA
input double angle_thresh_macro_s2_sell = -25.0;        // Pendenza minima negativa della trendline MACRO
input double angle_thresh_micro_s2_sell = -20.0;        // Pendenza minima negativa della trendline MICRO
input double price_dist_extra_s2_sell   = 100.0;        // Distanza minima tra prezzo e trendline EXTRA (SELL)
input double delta_tl_s2_sell           = 10.0;         // Differenza angolare tra le 3 TL per validazione SELL
input double index_s2_sell              = 0.8;          // Valore minimo dell‚Äôindice combinato per attivare SELL




//==============================//
// üéØ STRATEGIA 3
//==============================//
input group "üéØ Strategia 3 - Parametri Generali üéØ 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3"
input bool   enable_strategy_3           = true;        // Attiva o disattiva la Strategia 3 (blocco TP se eccesso positivo)
input bool   invert_strategy_3           = false;       // Inverte la logica BUY/SELL per test contrarian
input int    magic_strategy_3            = 110003;      // Numero magico univoco per la Strategia 3
input int    sl_pips_s3                  = 40;          // Stop Loss in pips per ogni ordine S3
input int    tp_pips_s3                  = 60;          // Take Profit in pips per ogni ordine S3
input int    trendline_bars_s3           = 20;          // Numero barre da considerare per costruzione trendline S3
input double equity_tp_s3                = 10.0;        // Profitto cumulativo per chiusura ordini di S3
input int    max_positions_s3            = 3;           // Numero massimo di posizioni contemporanee per S3
input double min_spacing_s3              = 5.0;         // Spaziatura minima tra ordini S3
input double trail_pips_s3               = 10.0;        // Trailing Stop in pips per ordini di S3

//------------------------------//
// üü¢ Strategia 3 - BUY Trigger
//------------------------------//
input group "üü¢ Strategia 3 - BUY Settings"
input bool   s3_use_buy                  = true;        // Abilita il lato BUY per Strategia 3
input double angle_thresh_extra_s3_buy  = 30.0;         // Pendenza minima positiva della trendline EXTRA
input double angle_thresh_macro_s3_buy  = 25.0;         // Pendenza minima positiva della trendline MACRO
input double angle_thresh_micro_s3_buy  = 20.0;         // Pendenza minima positiva della trendline MICRO
input double price_dist_extra_s3_buy    = 100.0;        // Distanza minima tra prezzo e trendline EXTRA (BUY)
input double delta_tl_s3_buy            = 10.0;         // Differenza angolare tra le 3 TL per validazione BUY
input double index_s3_buy               = 0.8;          // Valore minimo dell‚Äôindice combinato per attivare BUY 

//------------------------------//
// üî¥ Strategia 3 - SELL Trigger
//------------------------------//
input group "üî¥ Strategia 3 - SELL Settings"
input bool   s3_use_sell                 = true;        // Abilita il lato SELL per Strategia 3
input double angle_thresh_extra_s3_sell = -30.0;        // Pendenza minima negativa della trendline EXTRA
input double angle_thresh_macro_s3_sell = -25.0;        // Pendenza minima negativa della trendline MACRO
input double angle_thresh_micro_s3_sell = -20.0;        // Pendenza minima negativa della trendline MICRO
input double price_dist_extra_s3_sell   = 100.0;        // Distanza minima tra prezzo e trendline EXTRA (SELL)
input double delta_tl_s3_sell           = 10.0;         // Differenza angolare tra le 3 TL per validazione SELL
input double index_s3_sell              = 0.8;          // Valore minimo dell‚Äôindice combinato per attivare SELL

//------------------------------//
// üî¥ Strategia 4 - 
//------------------------------//

input group "üß† Strategia 4 - Parametri Generali üß† 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4"
input bool     enable_strategy_4           = true;        // Attiva o disattiva la Strategia 4 (logica su soglie negative - blocco TP)
input bool     invert_strategy_4           = false;       // Inverte la logica BUY/SELL per test contrarian
input int      magic_strategy_4            = 110004;      // Numero magico univoco per la Strategia 4
input int      sl_pips_s4                  = 40;          // Stop Loss in pips per ogni ordine S4
input int      tp_pips_s4                  = 60;          // Take Profit in pips per ogni ordine S4
input int      trendline_bars_s4           = 20;          // Numero barre da considerare per costruzione trendline S4
input double   equity_tp_s4                = 10.0;        // Profitto cumulativo per chiusura ordini di S4
input int      max_positions_s4            = 3;           // Numero massimo di posizioni contemporanee per S4
input double   min_spacing_s4              = 5.0;         // Spaziatura minima tra ordini S4
input double   trail_pips_s4               = 10.0;        // Trailing Stop in pips per ordini di S4
input double   angle_thresh_extra_s4       = 30.0;        // Pendenza soglia EXTRA (media)
input double   angle_thresh_macro_s4       = 25.0;        // Pendenza soglia MACRO (media)
input double   angle_thresh_micro_s4       = 20.0;        // Pendenza soglia MICRO (media)
input double   min_dist_extra_s4           = 100.0;       // Distanza min tra prezzo e TL EXTRA


//------------------------------//
// üü¢ Strategia 4 - BUY Trigger
//------------------------------//
input group "üü¢ Strategia 4 - BUY Settings"
input bool     s4_use_buy                  = true;        // Abilita il lato BUY per Strategia 4
input double   angle_thresh_extra_s4_buy   = 30.0;        // Pendenza minima positiva della trendline EXTRA
input double   angle_thresh_macro_s4_buy   = 25.0;        // Pendenza minima positiva della trendline MACRO
input double   angle_thresh_micro_s4_buy   = 20.0;        // Pendenza minima positiva della trendline MICRO
input double   price_dist_extra_s4_buy     = 100.0;       // Distanza minima tra prezzo e trendline EXTRA (BUY)
input double   delta_tl_s4_buy             = 10.0;        // Differenza angolare tra le 3 TL per validazione BUY
input double   index_s4_buy                = 0.8;         // Valore minimo dell‚Äôindice combinato per attivare BUY (blocco TP)
input double   s4_equity_tp_buy            = 10.0;        // Equity TP lato BUY (S4)
input int      s4_max_positions_buy        = 3;           // Max posizioni BUY S4
input double   s4_min_spacing_buy          = 5.0;         // Spaziatura minima BUY S4


//------------------------------//
// üî¥ Strategia 4 - SELL Trigger
//------------------------------//
input group "üî¥ Strategia 4 - SELL Settings"
input bool     s4_use_sell                 = true;        // Abilita il lato SELL per Strategia 4
input double   angle_thresh_extra_s4_sell  = -30.0;       // Pendenza minima negativa della trendline EXTRA
input double   angle_thresh_macro_s4_sell  = -25.0;       // Pendenza minima negativa della trendline MACRO
input double   angle_thresh_micro_s4_sell  = -20.0;       // Pendenza minima negativa della trendline MICRO
input double   price_dist_extra_s4_sell    = 100.0;       // Distanza minima tra prezzo e trendline EXTRA (SELL)
input double   delta_tl_s4_sell            = 10.0;        // Differenza angolare tra le 3 TL per validazione SELL
input double   index_s4_sell               = 0.8;         // Valore minimo dell‚Äôindice combinato per attivare SELL (blocco TP)
input double   s4_equity_tp_sell           = 10.0;        // Equity TP lato SELL (S4)
input int      s4_max_positions_sell       = 3;           // Max posizioni SELL S4
input double   s4_min_spacing_sell         = 5.0;         // Spaziatura minima SELL S4

//==============================//
// ‚ö†Ô∏è GESTIONE RISCHIO E TRAILING
//==============================//

//--- üìâ Parametri di rischio e SL/TP di base
input group "‚öñÔ∏è Gestione Rischio"
input double inp_base_volume          = 0.01;   // Lotto iniziale base
input double inp_max_volume           = 0.1;    // Volume massimo consentito
input double inp_initial_capital      = 1000.0; // Capitale di riferimento per il calcolo dinamico
input int    inp_sl_pips              = 30;     // SL di base usato in fallback (in pips)
input int    inp_tp_pips              = 50;     // TP di base usato in fallback (in pips)

//--- üí° Strategia di volume dinamico
input group "üìä Strategia Volume"
input ENUM_LOT_STRATEGY inp_lot_strategy = FIXED_LOT; // FIXED_LOT, MARTINGALE, SUMMING ecc.
input double inp_increment_index     = 0.1;    // Incremento percentuale (per strategie dinamiche)
input double inp_martingale_mult     = 2.0;    // Moltiplicatore martingala (se usata)
input double inp_sum_increment       = 0.01;   // Lotto fisso da sommare (se strategia SUMMING)
input bool   inp_use_volume_reset    = true;   // Azzeramento lotto dopo recupero perdita
input double inp_reset_trigger_percent = 10.0; // Soglia % di profitto che azzera (soft reset)

//--- üîÅ Trailing dinamico su momentum
input group "üìâ Trailing Dinamico"
input double inp_spike_threshold_points = 300; // Spike massimo tollerato nella candela corrente
input double inp_profit_trigger_points = 200;  // Profitto minimo richiesto prima di attivare trailing
input double inp_trail_pips            = 50;   // Valore base del trailing (modificato dal momentum)
input double inp_momentum_base         = 30;   // Base normalizzata del momentum per scaling
input double inp_momentum_min_factor   = 1.0;  // Fattore minimo sul trailing
input double inp_momentum_max_factor   = 3.0;  // Fattore massimo sul trailing

//--- üè∑Ô∏è Etichetta generale del sistema
input string inp_label = "TrendlinePRO";       // Prefisso comune per etichette di trade e log






// === [GLOB] Variabili di tempo e intervalli ===
datetime last_extra_update = 0;
int extra_interval_sec = 300;

// === [GRAFICO] Etichette per trendline (LEFT / RIGHT) ===
string labels_left[6]  = { "MICRO", "MACRO", "EXTRA", "UPTrend", "DOWNtrend", "SUPPORT" };
string labels_right[6] = { "Delta Mac-Mic", "Delta Mac-Ext", "Delta Ext-Mic", "DIST", "MAXpick", "MINpick" };

// === [TREND INDEX] Valori indicizzati per logica strategica ===
int left_vals[6], right_vals[6];
double indexMicro, indexMacro, indexExtra;

// === [CONFIG] Struttura per parametri strategici (SL / TP / Magic / Label) ===
struct StrategyConfig {
   int sl_pips;
   int tp_pips;
   int magic;
   string label_prefix;
};

// === [OGGETTI CORE] Trade, Parametri, Esecuzione ===
CTrade trade;


CStrategyParamsManager strategyParams;

S1Params s1;
S2Params s2;
S3Params s3;
S4Params s4;


CTradeExecutor executor;

// === [VOLUME MANAGER] Calcolo lotti e gestione rischio ===
CVolumeManager trade_volume;
CVolumeManager volumeManager;

// === [STRATEGIE CONFIGURATE] Configurazioni separate S1, S2, S3 ===
StrategyConfig config_s1, config_s2, config_s3;

// === [STRATEGIE DECISIONALI] Controllo segnali per ogni strategia ===
CTradeDecisionManager strategy2_decision;
CTradeDecisionManager decision;

// === [TRACKING VISIVO] Dashboard grafica delle trendline ===
CTrackCounterDrawer trackDrawer;

// === [AUDIT] Verifica coerenza parametri e soglie ===
AuditCheck audit;





// Dichiara le variabili 

S1Params s1_params;
S2Params s2_params;
S3Params s3_params;
S4Params s4_params;

int OnInit()
{
   Print("üîÑ Inizializzazione Expert Advisor...");

   // === [G] INIZIALIZZAZIONE PARAMETRI STRATEGICI ===
   strategyParams.Init(
      tp_pips_s1, tp_pips_s2, tp_pips_s3, tp_pips_s4,
      sl_pips_s1, sl_pips_s2, sl_pips_s3, sl_pips_s4,
      magic_strategy_1, magic_strategy_2, magic_strategy_3, magic_strategy_4,
      enable_strategy_1, enable_strategy_2, enable_strategy_3, enable_strategy_4,
      invert_strategy_1, invert_strategy_2, invert_strategy_3, invert_strategy_4,
      s1_use_buy, s2_use_buy, s3_use_buy, s4_use_buy,
      s1_use_sell, s2_use_sell, s3_use_sell, s4_use_sell,
      equity_tp_s1, equity_tp_s2, equity_tp_s3, equity_tp_s4,
      max_positions_s1, max_positions_s2, max_positions_s3, max_positions_s4,
      min_spacing_s1, min_spacing_s2, min_spacing_s3, min_spacing_s4,
      trail_pips_s1, trail_pips_s2, trail_pips_s3, trail_pips_s4,
      trendline_bars_s1, trendline_bars_s2, trendline_bars_s3, trendline_bars_s4,
      angle_thresh_extra_s4_buy, angle_thresh_macro_s4_buy,
      angle_thresh_micro_s4_buy, price_dist_extra_s4_buy
   );

   // === [MAPPING] CONVERSIONE STRATEGY PARAMS ===
   StrategyParams sp1 = strategyParams.GetS1();
   StrategyParams sp2 = strategyParams.GetS2();
   StrategyParams sp3 = strategyParams.GetS3();
   StrategyParams sp4 = strategyParams.GetS4();

   S1Params = ConvertToS1Params(sp1);
   S2Params = ConvertToS2Params(sp2);
   S3Params = ConvertToS3Params(sp3);
   S4Params = ConvertToS4Params(sp4);

   // === [A] AUDIT PRE-CHECK ===
   AuditParamsCheck::RunAllAudits(
   ConvertToS1Params(strategyParams.GetS1()),
   ConvertToS2Params(strategyParams.GetS2()),
   ConvertToS3Params(strategyParams.GetS3()),
   ConvertToS4Params(strategyParams.GetS4()),
   bypass_filter
);

   // === [V] CONFIGURAZIONE VOLUME DINAMICO ===
   volumeManager.Configure(
      inp_lot_strategy,
      inp_base_volume,
      inp_max_volume,
      inp_initial_capital,
      inp_increment_index,
      inp_martingale_mult,
      inp_sum_increment,
      inp_use_volume_reset,
      inp_reset_trigger_percent
   );
   volumeManager.SetDebugMode(true);

   // === [E] CONFIG EXECUTOR ===
   executor.Configure(magic_strategy_2, inp_label);
   executor.volume = volumeManager;

   // === [D] CONFIGURAZIONE DECISION MANAGER ===
   decision.SetDeltaThresholds(delta_mm_s1, delta_me_s1, delta_em_s1);
   decision.SetRetracementThresholds(angle_thresh_ext, angle_thresh_micmac, delta_min_retracement, max_dist_retracement);
   decision.SetDebug(debug_strategy);

   // === [S] CONFIG LABEL STRATEGIE ===
   config_s1.sl_pips = sl_pips_s1;
   config_s1.tp_pips = tp_pips_s1;
   config_s1.magic = magic_strategy_1;
   config_s1.label_prefix = "Strategy 1 - ";

   config_s2.sl_pips = sl_pips_s2;
   config_s2.tp_pips = tp_pips_s2;
   config_s2.magic = magic_strategy_2;
   config_s2.label_prefix = "Strategy 2 - ";

   config_s3.sl_pips = sl_pips_s3;
   config_s3.tp_pips = tp_pips_s3;
   config_s3.magic = magic_strategy_3;
   config_s3.label_prefix = "Strategy 3 - ";

   // === [T] BLOCCO STRATEGY TESTER ===
   if (MQLInfoInteger(MQL_TESTER) && !bypass_filter) {
      Print("üö´ Audit disattivato in Strategy Tester (bypass_filter = false)");
      return INIT_SUCCEEDED;
   }

   return INIT_SUCCEEDED;
}





void OnDeinit(const int reason) {
    for(int i = 0; i < 6; i++) {
        ObjectDelete(0, "LabelLeft" + IntegerToString(i));
        ObjectDelete(0, "LabelRight" + IntegerToString(i));
    }
    for(int i = 0; i < 3; i++)
        ObjectDelete(0, "Trendline" + IntegerToString(i));
        
    ObjectDelete(0, "VolumeOverlay");
    ObjectDelete(0, "LabelLeft_Lengths");  // ‚úÖ Etichetta extra dashboard vecchia
}





bool IsMarketFavorable()
{
   
   
   
   if (!enable_auto_normalizer)
      return true;

   double volatility = (iHigh(_Symbol, _Period, 1) - iLow(_Symbol, _Period, 1)) / _Point;
   double avg_volume = (double)iVolume(_Symbol, _Period, 1); // cast esplicito corretto

   if (volatility < min_volatility_pips)
   {
      Print("üìâ [Filtro Mercato] Volatilit√† insufficiente: ", volatility, "pips < ", min_volatility_pips);
      return false;
   }

   if (avg_volume < min_volume_tick_avg)
   {
      Print("üìâ [Filtro Mercato] Volume insufficiente: ", avg_volume, " < ", min_volume_tick_avg);
      return false;
   }

   return true;
}

#define OBJPROP_TIME1  8
#define OBJPROP_TIME2  9


   
   
datetime ObjectGetTimeByValue(long chart_id, string name, int prop_id)
{
   long val = 0;
   if (!ObjectGetInteger(chart_id, name, (ENUM_OBJECT_PROPERTY_INTEGER)prop_id, 0, val))
      return 0;

   return (datetime)val;
}   
  
  
   
string FormatStrategyLabel(string strategyCode, string direction, int magic)
{
   return StringFormat("%s %s #%d", strategyCode, direction, magic);
}


// Funzione unica per log

void LogOrderPreview(string strategyCode, string direction, int magic)
{
   string label = FormatStrategyLabel(strategyCode, direction, magic);
   Print("[INFO] Opening ", label);
}



double CalculateTrendlineVelocity(string name) {
   long t1_raw, t2_raw;
   if (!ObjectGetInteger(0, name, OBJPROP_TIME, 0, t1_raw) ||
       !ObjectGetInteger(0, name, OBJPROP_TIME, 1, t2_raw))
       return 0.0;

   datetime t1 = (datetime)t1_raw;
   datetime t2 = (datetime)t2_raw;

   double p1 = ObjectGetDouble(0, name, OBJPROP_PRICE, 0);
   double p2 = ObjectGetDouble(0, name, OBJPROP_PRICE, 1);

   double delta_price = MathAbs(p2 - p1);
   double delta_time  = (double)(t2 - t1) / 60.0;

   if (delta_time == 0.0) return 0.0;
   return delta_price / delta_time / _Point;
}




void OnTick()
{
   static datetime last_exec = 0;
   if (TimeCurrent() == last_exec) return;
   last_exec = TimeCurrent();

   double lot = volume.CalculateLot();

   if (!bypass_filter && !IsMarketFavorable()) return;

   UpdateTrendline("Trendline0", micro_bars);
   UpdateTrendline("Trendline1", macro_bars);
   if (TimeCurrent() - last_extra_update >= extra_interval_sec) {
      UpdateTrendline("Trendline2", extra_bars);
      last_extra_update = TimeCurrent();
   }

   double a_micro = GetSlope("Trendline0");
   double a_macro = GetSlope("Trendline1");
   double a_extra = GetSlope("Trendline2");
   double dist     = (iClose(_Symbol, _Period, 0) - ObjectGetDouble(0, "Trendline2", OBJPROP_PRICE, 1)) / _Point;

   int up      = CountUP(count_window);
   int down    = CountDOWN(count_window);
   int support = CountSUPPORT(count_window);

   double delta_mm = MathAbs(a_macro - a_micro);
   double delta_me = MathAbs(a_macro - a_extra);
   double delta_em = MathAbs(a_extra - a_micro);

   decision.LoadData(a_micro, a_macro, a_extra, delta_mm, delta_me, delta_em, dist, up, down, support);

   ApplyTrailingStop((int)inp_trail_pips);

   // === TRACK COUNTER ===
   string names[] = { "MICRO", "MACRO", "EXTRA" };
   double angles[] = { a_micro, a_macro, a_extra };
   double dirs[] = { CalculateTrendlineVelocity("Trendline0"),
                     CalculateTrendlineVelocity("Trendline1"),
                     CalculateTrendlineVelocity("Trendline2") };
   double deltas[] = { a_micro - a_macro, a_macro - a_extra, a_extra - a_micro };
   double volumes[] = { 1.9, 2.3, 2.7 }; // Placeholder
   int bars[] = { TrendlineLengthBars("Trendline0"),
                  TrendlineLengthBars("Trendline1"),
                  TrendlineLengthBars("Trendline2") };

   trackDrawer.ClearTrackCounter();
   trackDrawer.Draw(names, angles, dirs, dirs, bars, deltas, volumes);

   // === STRATEGIA 1 ===
   if (s1.enabled && !executor.HasOpenTrade(s1.magic)) {
      string dir = s1.invert ? "SELL" : "BUY";
      string label = FormatStrategyLabel("S1", dir, s1.magic);
      if (s1.use_buy && decision.CheckCompressionBUY()) {
         Print("[INFO] Opening ", label);
         if (dir == "BUY") executor.OpenBuy(lot, s1.sl_pips, s1.tp_pips, s1.magic, label);
         else executor.OpenSell(lot, s1.sl_pips, s1.tp_pips, s1.magic, label);
      }
      if (s1.use_sell && decision.CheckCompressionSELL()) {
         Print("[INFO] Opening ", label);
         if (dir == "BUY") executor.OpenBuy(lot, s1.sl_pips, s1.tp_pips, s1.magic, label);
         else executor.OpenSell(lot, s1.sl_pips, s1.tp_pips, s1.magic, label);
      }
   }

   // === STRATEGIA 2 ===
   if (s2.enabled && !executor.HasOpenTrade(s2.magic)) {
      double v_micro = CalculateTrendlineVelocity("Trendline0");

      bool buy = decision.CheckContrarianCumulative(true, a_micro, a_macro, a_extra, v_micro, dist,
                  s2.angle_thresh_macro_buy, s2.angle_thresh_extra_buy, s2.angle_max_micro_buy,
                  s2.velocity_min_micro_buy, s2.min_dist_extra_buy);

      bool sell = decision.CheckContrarianCumulative(false, a_micro, a_macro, a_extra, v_micro, dist,
                  s2.angle_thresh_macro, s2.angle_thresh_extra, s2.angle_min_micro,
                  s2.velocity_min_micro, s2.min_dist_extra);

      string dir = s2.invert ? "SELL" : "BUY";
      string label = FormatStrategyLabel("S2", dir, s2.magic);

      if (s2.use_buy && buy) {
         Print("[INFO] Opening ", label);
         if (dir == "BUY") executor.OpenBuy(lot, s2.sl_pips, s2.tp_pips, s2.magic, label);
         else executor.OpenSell(lot, s2.sl_pips, s2.tp_pips, s2.magic, label);
      }

      if (s2.use_sell && sell) {
         Print("[INFO] Opening ", label);
         if (dir == "BUY") executor.OpenBuy(lot, s2.sl_pips, s2.tp_pips, s2.magic, label);
         else executor.OpenSell(lot, s2.sl_pips, s2.tp_pips, s2.magic, label);
      }
   }

   // === STRATEGIA 3 ===
   if (s3.enabled && !executor.HasOpenTrade(s3.magic)) {
      string dir = s3.invert ? "SELL" : "BUY";
      string label = FormatStrategyLabel("S3", dir, s3.magic);

      if (s3.use_buy && decision.CheckRetracementBUY()) {
         Print("[INFO] Opening ", label);
         if (dir == "BUY") executor.OpenBuy(lot, s3.sl_pips, s3.tp_pips, s3.magic, label);
         else executor.OpenSell(lot, s3.sl_pips, s3.tp_pips, s3.magic, label);
      }

      if (s3.use_sell && decision.CheckRetracementSELL()) {
         Print("[INFO] Opening ", label);
         if (dir == "BUY") executor.OpenBuy(lot, s3.sl_pips, s3.tp_pips, s3.magic, label);
         else executor.OpenSell(lot, s3.sl_pips, s3.tp_pips, s3.magic, label);
      }
   }

   // === STRATEGIA 4 ===
   if (s4.enabled && !executor.HasOpenTrade(s4.magic)) {
      string dir = s4.invert ? "SELL" : "BUY";
      string label = FormatStrategyLabel("S4", dir, s4.magic);

      if (s4.use_buy && decision.CheckContrarianAuto(true,
         s4.angle_thresh_extra, s4.angle_thresh_macro, s4.angle_min_micro,
         s4.velocity_min_micro, s4.min_dist_extra)) {
         Print("[INFO] Opening ", label);
         if (dir == "BUY") executor.OpenBuy(lot, s4.sl_pips, s4.tp_pips, s4.magic, label);
         else executor.OpenSell(lot, s4.sl_pips, s4.tp_pips, s4.magic, label);
      }

      if (s4.use_sell && decision.CheckContrarianAuto(false,
         s4.angle_thresh_extra, s4.angle_thresh_macro, s4.angle_min_micro,
         s4.velocity_min_micro, s4.min_dist_extra)) {
         Print("[INFO] Opening ", label);
         if (dir == "BUY") executor.OpenBuy(lot, s4.sl_pips, s4.tp_pips, s4.magic, label);
         else executor.OpenSell(lot, s4.sl_pips, s4.tp_pips, s4.magic, label);
      }
   }
}






bool CheckContrarianAuto(bool isBuy,
                         double angleMicro, double angleMacro, double angleExtra,
                         double distancePriceToExtra,
                         double idxMicro, double idxMacro, double idxExtra,
                         double thresholdDistanceBUY, double thresholdDistanceSELL,
                         double minIndexBuy, double maxIndexSell)
{
   if (isBuy)
   {
      return (
         angleMicro > 0 && angleMacro > 0 && angleExtra > 0 &&
         distancePriceToExtra > thresholdDistanceBUY &&
         idxMicro > minIndexBuy &&
         idxMacro > minIndexBuy &&
         idxExtra > minIndexBuy
      );
   }
   else
   {
      return (
         angleMicro < 0 && angleMacro < 0 && angleExtra < 0 &&
         distancePriceToExtra < thresholdDistanceSELL &&
         idxMicro < maxIndexSell &&
         idxMacro < maxIndexSell &&
         idxExtra < maxIndexSell
      );
   }
}
   

void ClosePositionByMagic(int magic) {
   for (int i = PositionsTotal() - 1; i >= 0; i--) {
      if (PositionGetTicket(i) == 0) continue;
      ulong ticket = PositionGetTicket(i);
      if (!PositionSelectByTicket(ticket)) continue;
      if ((int)PositionGetInteger(POSITION_MAGIC) == magic) {
         string symbol = PositionGetString(POSITION_SYMBOL);
         double volume = PositionGetDouble(POSITION_VOLUME);
         long type = PositionGetInteger(POSITION_TYPE);

         if (type == POSITION_TYPE_BUY)
            trade.PositionClose(symbol);
         else if (type == POSITION_TYPE_SELL)
            trade.PositionClose(symbol);
      }
   }
}





void UpdateTrendline(string name, int bars_back) {
    if(Bars(_Symbol,_Period)<bars_back) return;

    datetime t1 = iTime(_Symbol,_Period,bars_back);
    double p1 = GetPriceValue(bars_back, TL_CalcBase);  // sostituito iClose con GetPriceValue
    datetime t2 = iTime(_Symbol,_Period,0);
    double p2 = GetPriceValue(0, TL_CalcBase);          // sostituito iClose con GetPriceValue

    if(ObjectFind(0,name)<0)
        ObjectCreate(0,name,OBJ_TREND,0,t1,p1,t2,p2);
    else {
        ObjectMove(0,name,0,t1,p1);
        ObjectMove(0,name,1,t2,p2);
    }
    double angle = GetSlope(name);
    ObjectSetInteger(0,name,OBJPROP_COLOR,(angle>=0)?clrLime:clrRed);
    ObjectSetInteger(0,name,OBJPROP_WIDTH,StringToInteger(StringSubstr(name,-1))+1);
}


double GetSlope(string obj) {
    long t1_raw, t2_raw;
    if(!ObjectGetInteger(0, obj, OBJPROP_TIME, 0, t1_raw) ||
       !ObjectGetInteger(0, obj, OBJPROP_TIME, 1, t2_raw))
        return 0.0;
    datetime t1 = (datetime)t1_raw;
    datetime t2 = (datetime)t2_raw;
    double p1 = ObjectGetDouble(0, obj, OBJPROP_PRICE, 0);
    double p2 = ObjectGetDouble(0, obj, OBJPROP_PRICE, 1);
    double dx = (double)(t2 - t1) / 60.0;
    double dy = (p2 - p1) / _Point;
    double factor = 2.0;
    if(dx == 0.0) return 0.0;
    return MathArctan((dy / dx) * factor) * 180.0 / M_PI;
}

//+------------------------------------------------------------------+
//| NUOVA FUNZIONE: GetTrendRealStrength()                          |
//| Metodo: RGOLD - Strategia 4 (e futura estensione S1-S3)         |
//| Descrizione: calcola la "forza reale" di una trendline          |
//| sulla base dello scostamento diretto del prezzo e              |
//| dell‚Äôoscillazione interna tra punto A (inizio) e B (fine).      |
//+------------------------------------------------------------------+

// === PATCH PER STRENGTH REALE ===
double GetTrendRealStrength(string trendName) {
   datetime t1 = (datetime)ObjectGetInteger(0, trendName, OBJPROP_TIME, 0);
   datetime t2 = (datetime)ObjectGetInteger(0, trendName, OBJPROP_TIME, 1);
   double   p1 = ObjectGetDouble(0, trendName, OBJPROP_PRICE, 0);
   double   p2 = ObjectGetDouble(0, trendName, OBJPROP_PRICE, 1);
   int bars = TrendlineLengthBars(trendName);
   if (bars == 0) return 0.0;
   double scostamento = MathAbs(p2 - p1);
   return scostamento / bars / _Point;
}

int TrendlineLengthBars(string trendName) {
   datetime t1 = (datetime)ObjectGetInteger(0, trendName, OBJPROP_TIME, 0);
   datetime t2 = (datetime)ObjectGetInteger(0, trendName, OBJPROP_TIME, 1);
   return Bars(_Symbol, _Period, t1, t2);
}

//+------------------------------------------------------------------+
//| NOTE:                                                           |
//| Valori vicini a 1 ‚Üí trend forte e coerente                      |
//| Valori < 0.3 ‚Üí oscillazioni laterali o poco direzionali        |
//| Valori 0 ‚Üí anomalia o barra piatta                             |
//+------------------------------------------------------------------+


// === PATCH PER CALCULATEMETRICS ===
void CalculateMetrics() {
    double a0 = GetSlope("Trendline0");
    double a1 = GetSlope("Trendline1");
    double a2 = GetSlope("Trendline2");

    double v0 = CalculateTrendlineVelocity("Trendline0");
    double v1 = CalculateTrendlineVelocity("Trendline1");
    double v2 = CalculateTrendlineVelocity("Trendline2");

    // ‚úÖ Nuovi valori di forza direzionale realistica
    double f0 = GetTrendRealStrength("Trendline0");  // MICRO
    double f1 = GetTrendRealStrength("Trendline1");  // MACRO
    double f2 = GetTrendRealStrength("Trendline2");  // EXTRA

    double dist = (iClose(_Symbol,_Period,0)-ObjectGetDouble(0,"Trendline2",OBJPROP_PRICE,1))/_Point;

    

    // === TRACK COUNTER - Nuova tabella forza trend (logica grezza temporanea su LabelLeft_Lengths)
    string line = 
      "EXTRA: " + StringFormat("Idx: %.2f | %.1f¬∞ | %.2fpt/min | Bars: %d", f2, a2, v2, TrendlineLengthBars("Trendline2")) + "\n" +
      "MACRO: " + StringFormat("Idx: %.2f | %.1f¬∞ | %.2fpt/min | Bars: %d", f1, a1, v1, TrendlineLengthBars("Trendline1")) + "\n" +
      "MICRO: " + StringFormat("Idx: %.2f | %.1f¬∞ | %.2fpt/min | Bars: %d", f0, a0, v0, TrendlineLengthBars("Trendline0"));

    
}





int CountUP(int window) {
    int count = 0;
    for(int i=1; i<=window; i++) {
        double ma = GetSlope("Trendline1");
        double mi = GetSlope("Trendline0");
        if(mi > ma) count++;
    }
    return count;
}

int CountDOWN(int window) {
    int count = 0;
    for(int i=1; i<=window; i++) {
        double ma = GetSlope("Trendline1");
        double mi = GetSlope("Trendline0");
        if(mi < ma) count++;
    }
    return count;
}

int CountSUPPORT(int window) {
    int count = 0;
    for(int i=1; i<=window; i++) {
        double a0 = GetSlope("Trendline0");
        double a1 = GetSlope("Trendline1");
        double a2 = GetSlope("Trendline2");
        if((a0 > 0 && a1 > 0 && a2 > 0) || (a0 < 0 && a1 < 0 && a2 < 0))
            count++;
    }
    return count;
}

double GetMomentumCurrentTF() {
    double open = iOpen(_Symbol, _Period, 0);
    double close = iClose(_Symbol, _Period, 0);
    return MathAbs(close - open) / _Point;
}

double NormalizeMomentum(double momentum) {
    return MathMin(inp_momentum_max_factor, MathMax(inp_momentum_min_factor, momentum / inp_momentum_base));
}



void ApplyTrailingStop(int trailPips) {
   if (PositionsTotal() == 0) return;

   double momentum = GetMomentumCurrentTF();
   double factor = NormalizeMomentum(momentum);
   double adjustedTrail = trailPips / factor;

   // Ciclo sulle posizioni aperte
for (int i = 0; i < PositionsTotal(); i++) {
   ulong ticket = PositionGetTicket(i);
   if (!PositionSelectByTicket(ticket)) continue;

   string symbol = PositionGetString(POSITION_SYMBOL);
   long type = PositionGetInteger(POSITION_TYPE);
   double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);

   double open = PositionGetDouble(POSITION_PRICE_OPEN);
   double sl = PositionGetDouble(POSITION_SL);
   double tp = PositionGetDouble(POSITION_TP);

   // Prezzo attuale
   double price = (type == POSITION_TYPE_BUY)
                  ? SymbolInfoDouble(symbol, SYMBOL_BID)
                  : SymbolInfoDouble(symbol, SYMBOL_ASK);

   // Profitto in punti, non in valuta
   double profit_points = MathAbs(price - open) / point;

   // === FILTRO 1: profitto minimo prima del trailing dinamico
   if (profit_points < inp_profit_trigger_points) {
      Print("‚è∏Ô∏è Trailing bloccato: profitto attuale ", profit_points,
            "pt < soglia ", inp_profit_trigger_points, "pt");
      continue;
   }

   // === FILTRO 2: spike eccessivo nella candela corrente
   double candle_spike = iHigh(symbol, _Period, 0) - iLow(symbol, _Period, 0);
   if (candle_spike > inp_spike_threshold_points * point) {
      Print("‚ö†Ô∏è Spike rilevato nella candela: ", candle_spike / point,
            "pt > soglia ", inp_spike_threshold_points, "pt");
      continue;
   }

   // === Calcolo trailing dinamico basato su momentum
   double momentum = GetMomentumCurrentTF();
   double factor = NormalizeMomentum(momentum);
   double adjustedTrail = inp_trail_pips / factor;

   // === Nuovo SL calcolato
   double new_sl;
   if (type == POSITION_TYPE_BUY) {
      new_sl = NormalizeDouble(price - adjustedTrail * point, digits);
      if (sl < new_sl)
         executor.ModifyPosition(ticket, new_sl, tp);
   }
   else if (type == POSITION_TYPE_SELL) {
      new_sl = NormalizeDouble(price + adjustedTrail * point, digits);
      if (sl > new_sl || sl == 0.0)
         executor.ModifyPosition(ticket, new_sl, tp);
   }
   
   string lengths = StringFormat("LenMic: %d | LenMac: %d | LenExt: %d",
   TrendlineLengthBars("Trendline0"),
   TrendlineLengthBars("Trendline1"),
   TrendlineLengthBars("Trendline2"));

ObjectSetString(0, "LabelLeft5", OBJPROP_TEXT, lengths);

   // Audit opzionale
   AuditCheck::CheckTrailingLogic(profit_points, momentum, inp_profit_trigger_points, inp_momentum_base);
}
}


