//+------------------------------------------------------------------+
//| TrendlineStatsCollector_PRO_01_v1.06.mq5                         |
//| Copyright 2025, ProfitPickers - vitoiacobellis.it                |
//| https://www.vitoiacobellis.it                                    |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, ProfitPickers - vitoiacobellis.it"
#property link      "https://www.vitoiacobellis.it"
#property version   "1.06"
#property strict
#property description "EA di analisi trendline macro-micro, delta e dashboard statistica."

#include <Trade/Trade.mqh>
#include <stdlib.mqh>


#include "../Include/CTradeDecisionManager.mqh"
#include "../Include/CTradeExecutor.mqh"
#include "../Include/CVolumeManager.mqh"
#include "../Include/AuditCheck.mqh"
#include "../Include/CTrendlineAnalyzer.mqh"
#include "../Include/CStrategyParamsManager.mqh"
#include "../Include/CStrategyParamsManager.mqh"
#include <ChartObjects/ChartObjectsLines.mqh>
#include "../Include/CTrackCounterDrawer.mqh"
#include "../Include/CAuditCheck.mqh"
#include "../Include/AuditParamsCheck.mqh"

//==============================//
// ORIGINE DATI E TRENDLINE     //
//==============================//
input group "bypass_filter per abilitare audit anche in Strategy Tester"
input bool bypass_filter = true;  // üîì Esegui Audit anche nel Strategy Tester


//==============================//
// ORIGINE DATI E TRENDLINE     //
//==============================//
input group "ORIGINE DATI E TRENDLINE"
input ENUM_TLBaseCalc TL_CalcBase = TL_CLOSE;
input int TL_MA_Period = 14;

input group "Trendline Settings"
input int micro_bars = 10;
input int macro_bars = 50;
input int extra_bars = 300;
input int count_window = 20;

//==============================//
//      MODALITA' LOG           //
//==============================//
input bool debug_strategy = true; // Attiva o disattiva la modalit√† di log [DEBUG]

//==============================//
// TRAILING PIPS STRATEGIA     //
//==============================//
input group "TRAILING PIPS STRATEGIA"
input double trail_pips_s1 = 50.0;
input double trail_pips_s2 = 50.0;
input double trail_pips_s3 = 50.0;



//==============================//
// FILTRI E NORMALIZZAZIONE     //
//==============================//
input group "Filtri Volatilit√† e Volume"
input bool enable_auto_normalizer = true;
input double min_volatility_pips = 50;
input double min_volume_tick_avg = 100;


//==============================//
// ‚öôÔ∏è SOGLIE INDEX RENDLINE   I //
//==============================//
input group "Soglie Globali - Regolazione sensibilit√† strategie"
input double S4_MIN_INDEX_BUY  = 1000.0;   // Soglia minima INDEX per BUY
input double S4_MAX_INDEX_SELL = -1000.0;  // Soglia massima INDEX per SELL



//==============================//
// ‚öôÔ∏è SOGLIE GLOBALI - DELTA / ANGOLI //
//==============================//
input group "Soglie Globali - Regolazione sensibilit√† strategie"

// Soglia di compressione tra micro e macro trendline (Strategia 1)
input double delta_mm_s1 = 0.5;     // Diff. ang. max ¬∞ micro VS macro TL attiva compressione

// Soglia di compressione tra macro e extra trendline (Strategia 1)
input double delta_me_s1 = 0.5;     // Diff. ang. max ¬∞ macro VS extra TL attiva compressione


// Soglia di compressione tra extra e micro trendline (Strategia 1)
input double delta_em_s1 = 0.5;     // Diff. ang. max ¬∞ extra VS micro TL attiva compressione


// Soglia pendenza trendline extra per attivazione strategia 3
input double angle_thresh_ext = 25.0;   // Pendenza min ¬∞ trendline EXTRA attiva condizioni retracement

// Soglia pendenza combinata micro e macro per strategia 3
input double angle_thresh_micmac = 15.0; // Pendenza min ¬∞ richiesta a micro e macro TL per rilevare trend diretto

// Delta minimo tra macro ed extra per validare lo scenario di ritracciamento (Strategia 3)
input double delta_min_retracement = 0.3;  // Differenza angolare minima ¬∞ macro Vs extra attiva retracement

// Distanza massima tra prezzo e TL extra per ritracciamento valido (Strategia 3)
input double max_dist_retracement = 200.0; // Massima distanza in punti tra prezzo e TL extra x evento significativo




//==============================//
// üéØ STRATEGIA 1
//==============================//
input group "üéØ Strategia 1 - Parametri Generali üéØ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 "
input bool   enable_strategy_1     = true;     // (R) Attiva Strategia 1 - Rintracciamento
// (G) Permette esecuzione segnali di entrata in posizione
// (O) Determina se valutare i parametri BUY/SELL di S1
// (L) Usato nel modulo decisionale per abilitare la strategia
// (D) Disattiva completamente l'intera S1

input bool   invert_strategy_1     = false;    // (R) Inverti logica BUY/SELL
// (G) Consente di testare la strategia in modalit√† contrarian
// (O) Utile per debugging o analisi inverse
// (L) BUY diventa SELL e viceversa
// (D) Abilitabile separatamente per ogni strategia

input int    magic_strategy_1      = 110001;   // (R) Numero magico identificativo S1
// (G) Distingue gli ordini aperti da questa strategia
// (O) Facilita la gestione separata nel logging e protezione
// (L) Viene assegnato ad ogni ordine aperto
// (D) Unico per ogni strategia attiva

input int    sl_pips_s1            = 40;       // (R) Stop Loss in pips per S1
input int    tp_pips_s1            = 60;       // (R) Take Profit in pips per S1



//------------------------------//
// üü¢ STRATEGIA 1 - BUY
//------------------------------//
input group "üü¢ Strategia 1 - BUY Settings"
input bool   S1_UseBuy             = true;     // Abilita lato BUY
input double angle_thresh_extra_s1_buy = 30.0; // Pendenza min EXTRA (trend confermato)
input double angle_thresh_macro_s1_buy = 30.0; // Pendenza min MACRO (conferma direzionalit√†)
input double angle_max_micro_s1_buy    = -5.0; // Pendenza max negativa MICRO (pullback attivo)
input double velocity_min_micro_s1_buy = 1.0;  // Velocit√† min MICRO (esclude segnali lenti)
input double min_dist_extra_s1_buy     = 130.0;// Distanza minima dal prezzo alla EXTRA
input int    max_positions_s1_buy      = 5;    // Max posizioni BUY aperte
input double min_spacing_s1_buy        = 50.0; // Spaziatura minima tra ordini
input double equity_tp_s1_buy          = 10.0; // Profitto cumulativo per chiusura BUY

//------------------------------//
// üî¥ STRATEGIA 1 - SELL
//------------------------------//
input group "üî¥ Strategia 1 - SELL Settings"
input bool   S1_UseSell            = true;     // Abilita lato SELL
input double angle_thresh_extra_s1    = -30.0; // Pendenza min EXTRA (ribasso forte)
input double angle_thresh_macro_s1    = -30.0; // Pendenza min MACRO (conferma ribasso)
input double angle_min_micro_s1       = 5.0;   // Pendenza min MICRO (pullback attivo)
input double velocity_min_micro_s1    = 1.0;   // Velocit√† min MICRO
input double min_dist_extra_s1        = 130.0; // Distanza min prezzo-EXTRA (evita congestione)
input int    max_positions_s1         = 5;     // Max posizioni SELL aperte
input double min_spacing_s1           = 50.0;  // Spaziatura minima ordini SELL
input double equity_tp_s1             = 10.0;  // Profitto cumulativo per chiusura SELL


//==============================//
// STRATEGIA 2 - CONTRARIAN     //
//==============================//
input group "üéØ Strategia 2 - Parametri Generali ÔøΩ 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2"
input bool   enable_strategy_2     = true;     // Attiva o disattiva la Strategia 2
input bool   invert_strategy_2     = false;    // Inverte logica BUY/SELL (utile per testare segnali inversi)
input int    magic_strategy_2      = 110002;   // Numero magico per identificare gli ordini S2
input int    sl_pips_s2            = 40;       // Stop Loss in pips per ogni operazione S2
input int    tp_pips_s2            = 60;       // Take Profit in pips per ogni operazione S2

input group "üü¢ Strategia 2 - BUY Settings"
input bool   S2_UseBuy             = true;     // Abilita il lato BUY per Strategia 2
input double angle_thresh_extra_s2_buy = 30.0; // Min pendenza positiva EXTRA per considerare un eccesso rialzista
input double angle_thresh_macro_s2_buy = 30.0; // Min pendenza positiva MACRO per validare l‚Äôeccesso
input double angle_max_micro_s2_buy    = -5.0; // MICRO deve essere debole o divergente (massima pendenza)
input double velocity_min_micro_s2_buy = 1.0;  // Velocit√† minima MICRO per validare il movimento
input double min_dist_extra_s2_buy     = 130.0;// Distanza minima del prezzo da EXTRA (esclude congestioni)
input int    max_positions_s2_buy      = 5;    // Numero massimo posizioni BUY aperte in parallelo
input double min_spacing_s2_buy        = 50.0; // Distanza minima in pips tra aperture BUY
input double equity_tp_s2_buy          = 10.0; // Profitto totale in $ per chiudere le posizioni BUY di S2

input group "üî¥ Strategia 2 - SELL Settings"
input bool   S2_UseSell            = true;     // Abilita il lato SELL per Strategia 2
input double angle_thresh_extra_s2    = -30.0; // Pendenza negativa EXTRA oltre la soglia di eccesso ribassista
input double angle_thresh_macro_s2    = -30.0; // Pendenza negativa MACRO per confermare trend ribassista forte
input double angle_min_micro_s2       = 5.0;   // MICRO deve essere in divergenza (in salita)
input double velocity_min_micro_s2    = 1.0;   // Velocit√† minima MICRO per validazione segnale
input double min_dist_extra_s2        = 130.0; // Distanza minima dal prezzo a EXTRA (evita congestione)
input int    max_positions_s2         = 5;     // Max posizioni SELL parallele consentite
input double min_spacing_s2           = 50.0;  // Distanza minima in pips tra nuove posizioni SELL
input double equity_tp_s2             = 10.0;  // Profitto totale in $ per chiusura cumulativa SELL S2


//==============================//
// STRATEGIA 3 - TREND IS A FRIEND
//==============================//
input group "üìà Strategia 3 - Parametri Generali üìà 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3  "
input bool   enable_strategy_3     = true;
input bool   invert_strategy_3     = false;
input int    magic_strategy_3      = 110003;
input int    sl_pips_s3            = 40;
input int    tp_pips_s3            = 60;

input group "üü¢ Strategia 3 - BUY Settings"
input bool   S3_UseBuy             = true;
input double angle_thresh_extra_s3_buy = 30.0;
input double angle_thresh_macro_s3_buy = 30.0;
input double angle_max_micro_s3_buy    = -5.0;
input double velocity_min_micro_s3_buy = 1.0;
input double min_dist_extra_s3_buy     = 130.0;
input int    max_positions_s3_buy      = 5;
input double min_spacing_s3_buy        = 50.0;
input double equity_tp_s3_buy          = 10.0;

input group "üî¥ Strategia 3 - SELL Settings"
input bool   S3_UseSell            = true;
input double angle_thresh_extra_s3    = -30.0;
input double angle_thresh_macro_s3    = -30.0;
input double angle_min_micro_s3       = 5.0;
input double velocity_min_micro_s3    = 1.0;
input double min_dist_extra_s3        = 130.0;
input int    max_positions_s3         = 5;
input double min_spacing_s3           = 50.0;
input double equity_tp_s3             = 10.0;

/*
//=====================================================================//
// üìà Strategia 4 - Auto-Contrarian + Break & Reverse Sentinel         //
//=====================================================================//


*/

//==============================//
// ‚ö†Ô∏è GESTIONE RISCHIO E TRAILING
//==============================//

//--- üìâ Parametri di rischio e SL/TP di base
input group "‚öñÔ∏è Gestione Rischio"
input double inp_base_volume          = 0.01;   // Lotto iniziale base
input double inp_max_volume           = 0.1;    // Volume massimo consentito
input double inp_initial_capital      = 1000.0; // Capitale di riferimento per il calcolo dinamico
input int    inp_sl_pips              = 30;     // SL di base usato in fallback (in pips)
input int    inp_tp_pips              = 50;     // TP di base usato in fallback (in pips)

//--- üí° Strategia di volume dinamico
input group "üìä Strategia Volume"
input ENUM_LOT_STRATEGY inp_lot_strategy = FIXED_LOT; // FIXED_LOT, MARTINGALE, SUMMING ecc.
input double inp_increment_index     = 0.1;    // Incremento percentuale (per strategie dinamiche)
input double inp_martingale_mult     = 2.0;    // Moltiplicatore martingala (se usata)
input double inp_sum_increment       = 0.01;   // Lotto fisso da sommare (se strategia SUMMING)
input bool   inp_use_volume_reset    = true;   // Azzeramento lotto dopo recupero perdita
input double inp_reset_trigger_percent = 10.0; // Soglia % di profitto che azzera (soft reset)

//--- üîÅ Trailing dinamico su momentum
input group "üìâ Trailing Dinamico"
input double inp_spike_threshold_points = 300; // Spike massimo tollerato nella candela corrente
input double inp_profit_trigger_points = 200;  // Profitto minimo richiesto prima di attivare trailing
input double inp_trail_pips            = 50;   // Valore base del trailing (modificato dal momentum)
input double inp_momentum_base         = 30;   // Base normalizzata del momentum per scaling
input double inp_momentum_min_factor   = 1.0;  // Fattore minimo sul trailing
input double inp_momentum_max_factor   = 3.0;  // Fattore massimo sul trailing

//--- üè∑Ô∏è Etichetta generale del sistema
input string inp_label = "TrendlinePRO";       // Prefisso comune per etichette di trade e log







datetime last_extra_update = 0;
int extra_interval_sec = 300;
string labels_left[6] = {"MICRO", "MACRO", "EXTRA", "UPTrend", "DOWNtrend", "SUPPORT"};
string labels_right[6] = {"Delta Mac-Mic", "Delta Mac-Ext", "Delta Ext-Mic", "DIST", "MAXpick", "MINpick"};
string left_vals[6], right_vals[6];
double indexMicro, indexMacro, indexExtra;


struct StrategyConfig {
   int    sl_pips;
   int    tp_pips;
   int    magic;
   string label_prefix;
};

CTrade trade;
CStrategyParamsManager params;
CTradeExecutor executor;
CVolumeManager volume;
CVolumeManager volumeManager;
StrategyConfig config_s1, config_s2, config_s3;
CTradeDecisionManager strategy2_decision;
CTradeDecisionManager decision;

CTrackCounterDrawer trackDrawer;

AuditCheck audit;



int OnInit()
{
   Print("üîÑ Inizializzazione Expert Advisor...");

   // === [G] INIZIALIZZAZIONE PARAMETRI STRATEGICI ===
   params.Init(
      tp_pips_s1, tp_pips_s2, tp_pips_s3, // tp_pips_s4,
      sl_pips_s1, sl_pips_s2, sl_pips_s3, // sl_pips_s4,
      magic_strategy_1, magic_strategy_2, magic_strategy_3,//  magic_strategy_4,
      enable_strategy_1, enable_strategy_2, enable_strategy_3, // enable_strategy_4,
      invert_strategy_1, invert_strategy_2, invert_strategy_3,//  invert_strategy_4,
      S1_UseBuy, S2_UseBuy, S3_UseBuy, // S4_UseBuy,
      S1_UseSell, S2_UseSell, S3_UseSell, //  S4_UseSell,
      equity_tp_s1_buy, equity_tp_s2_buy, equity_tp_s3_buy,//  equity_tp_s4_buy,
      max_positions_s1_buy, max_positions_s2_buy, max_positions_s3_buy, //  max_positions_s4_buy,
      min_spacing_s1_buy, min_spacing_s2_buy, min_spacing_s3_buy, //  min_spacing_s4_buy,
      trail_pips_s1, trail_pips_s2, trail_pips_s3, // trail_pips_s4,
      micro_bars, macro_bars, extra_bars, extra_bars, //      angle_thresh_extra_s4, angle_thresh_macro_s4, angle_thresh_micro_s4, min_dist_extra_s4
   );

   // === [G] CONFIGURAZIONE VOLUME DINAMICO ===
   volumeManager.Configure(
      inp_lot_strategy,
      inp_base_volume,
      inp_max_volume,
      inp_initial_capital,
      inp_increment_index,
      inp_martingale_mult,
      inp_sum_increment,
      inp_use_volume_reset,
      inp_reset_trigger_percent
   );

   volumeManager.SetDebugMode(true);
   executor.Configure(magic_strategy_2, inp_label);
   executor.volume = volumeManager;

   // === [O] SETTAGGIO SOGLIE E DEBUG ===
   decision.SetDeltaThresholds(delta_mm_s1, delta_me_s1, delta_em_s1);
   decision.SetRetracementThresholds(angle_thresh_ext, angle_thresh_micmac, delta_min_retracement, max_dist_retracement);
   decision.SetDebug(debug_strategy);

   // === [L] CONFIG STRATEGIE: SL / TP / MAGIC / LABEL ===
   config_s1.sl_pips = sl_pips_s1;
   config_s1.tp_pips = tp_pips_s1;
   config_s1.magic = magic_strategy_1;
   config_s1.label_prefix = "Strategy 1 - ";

   config_s2.sl_pips = sl_pips_s2;
   config_s2.tp_pips = tp_pips_s2;
   config_s2.magic = magic_strategy_2;
   config_s2.label_prefix = "Strategy 2 - ";

   config_s3.sl_pips = sl_pips_s3;
   config_s3.tp_pips = tp_pips_s3;
   config_s3.magic = magic_strategy_3;
   config_s3.label_prefix = "Strategy 3 - ";

   // === [C] PROTEZIONE STRATEGY TESTER (NO AUDIT SE NON RICHIESTO) ===
   if (MQLInfoInteger(MQL_TESTER) && !bypass_filter) {
      Print("üö´ Audit disattivato in Strategy Tester (bypass_filter = false)");
      return INIT_SUCCEEDED;
   }

   // === [D] AUDIT PARAMETRI STRATEGIE ===
   S1Params s1;
   s1.useBuy = S1_UseBuy; s1.useSell = S1_UseSell;
   s1.angle_thresh_extra_buy = angle_thresh_extra_s1_buy;
   s1.angle_thresh_macro_buy = angle_thresh_macro_s1_buy;
   s1.angle_max_micro_buy    = angle_max_micro_s1_buy;
   s1.velocity_min_micro_buy = velocity_min_micro_s1_buy;
   s1.min_dist_extra_buy     = min_dist_extra_s1_buy;
   s1.max_positions_buy      = max_positions_s1_buy;
   s1.min_spacing_buy        = min_spacing_s1_buy;
   s1.equity_tp_buy          = equity_tp_s1_buy;
   s1.angle_thresh_extra     = angle_thresh_extra_s1;
   s1.angle_thresh_macro     = angle_thresh_macro_s1;
   s1.angle_min_micro        = angle_min_micro_s1;
   s1.velocity_min_micro     = velocity_min_micro_s1;
   s1.min_dist_extra         = min_dist_extra_s1;
   s1.max_positions          = max_positions_s1;
   s1.min_spacing            = min_spacing_s1;
   s1.equity_tp              = equity_tp_s1;

   S2Params s2;
   s2.useBuy = S2_UseBuy; s2.useSell = S2_UseSell;
   s2.angle_thresh_extra_buy = angle_thresh_extra_s2_buy;
   s2.angle_thresh_macro_buy = angle_thresh_macro_s2_buy;
   s2.angle_max_micro_buy    = angle_max_micro_s2_buy;
   s2.velocity_min_micro_buy = velocity_min_micro_s2_buy;
   s2.min_dist_extra_buy     = min_dist_extra_s2_buy;
   s2.max_positions_buy      = max_positions_s2_buy;
   s2.min_spacing_buy        = min_spacing_s2_buy;
   s2.equity_tp_buy          = equity_tp_s2_buy;
   s2.angle_thresh_extra     = angle_thresh_extra_s2;
   s2.angle_thresh_macro     = angle_thresh_macro_s2;
   s2.angle_min_micro        = angle_min_micro_s2;
   s2.velocity_min_micro     = velocity_min_micro_s2;
   s2.min_dist_extra         = min_dist_extra_s2;
   s2.max_positions          = max_positions_s2;
   s2.min_spacing            = min_spacing_s2;
   s2.equity_tp              = equity_tp_s2;

   S3Params s3;
   s3.useBuy = S3_UseBuy; s3.useSell = S3_UseSell;
   s3.angle_thresh_extra_buy = angle_thresh_extra_s3_buy;
   s3.angle_thresh_macro_buy = angle_thresh_macro_s3_buy;
   s3.angle_max_micro_buy    = angle_max_micro_s3_buy;
   s3.velocity_min_micro_buy = velocity_min_micro_s3_buy;
   s3.min_dist_extra_buy     = min_dist_extra_s3_buy;
   s3.max_positions_buy      = max_positions_s3_buy;
   s3.min_spacing_buy        = min_spacing_s3_buy;
   s3.equity_tp_buy          = equity_tp_s3_buy;
   s3.angle_thresh_extra     = angle_thresh_extra_s3;
   s3.angle_thresh_macro     = angle_thresh_macro_s3;
   s3.angle_min_micro        = angle_min_micro_s3;
   s3.velocity_min_micro     = velocity_min_micro_s3;
   s3.min_dist_extra         = min_dist_extra_s3;
   s3.max_positions          = max_positions_s3;
   s3.min_spacing            = min_spacing_s3;
   s3.equity_tp              = equity_tp_s3;
/*
   S4Params s4;
   s4.useBuy = S4_UseBuy; s4.useSell = S4_UseSell;
   s4.angle_thresh_extra_buy = angle_thresh_extra_s4_buy;
   s4.angle_thresh_macro_buy = angle_thresh_macro_s4_buy;
   s4.angle_max_micro_buy    = angle_max_micro_s4_buy;
   s4.velocity_min_micro_buy = velocity_min_micro_s4_buy;
   s4.min_dist_extra_buy     = min_dist_extra_s4_buy;
   s4.max_positions_buy      = max_positions_s4_buy;
   s4.min_spacing_buy        = min_spacing_s4_buy;
   s4.equity_tp_buy          = equity_tp_s4_buy;
   s4.angle_thresh_extra     = angle_thresh_extra_s4;
   s4.angle_thresh_macro     = angle_thresh_macro_s4;
   s4.angle_min_micro        = angle_min_micro_s4;
   s4.velocity_min_micro     = velocity_min_micro_s4;
   s4.min_dist_extra         = min_dist_extra_s4;
   s4.max_positions          = max_positions_s4;
   s4.min_spacing            = min_spacing_s4;
   s4.equity_tp              = equity_tp_s4;
*/

   AuditParamsCheck::RunAllAudits(s1, s2, s3, bypass_filter); // s4, 

   return INIT_SUCCEEDED;
}







void OnDeinit(const int reason) {
    for(int i = 0; i < 6; i++) {
        ObjectDelete(0, "LabelLeft" + IntegerToString(i));
        ObjectDelete(0, "LabelRight" + IntegerToString(i));
    }
    for(int i = 0; i < 3; i++)
        ObjectDelete(0, "Trendline" + IntegerToString(i));
        
    ObjectDelete(0, "VolumeOverlay");
    ObjectDelete(0, "LabelLeft_Lengths");  // ‚úÖ Etichetta extra dashboard vecchia
}





bool IsMarketFavorable()
{
   
   
   
   if (!enable_auto_normalizer)
      return true;

   double volatility = (iHigh(_Symbol, _Period, 1) - iLow(_Symbol, _Period, 1)) / _Point;
   double avg_volume = (double)iVolume(_Symbol, _Period, 1); // cast esplicito corretto

   if (volatility < min_volatility_pips)
   {
      Print("üìâ [Filtro Mercato] Volatilit√† insufficiente: ", volatility, "pips < ", min_volatility_pips);
      return false;
   }

   if (avg_volume < min_volume_tick_avg)
   {
      Print("üìâ [Filtro Mercato] Volume insufficiente: ", avg_volume, " < ", min_volume_tick_avg);
      return false;
   }

   return true;
}

#define OBJPROP_TIME1  8
#define OBJPROP_TIME2  9


   
   
datetime ObjectGetTimeByValue(long chart_id, string name, int prop_id)
{
   long val = 0;
   if (!ObjectGetInteger(chart_id, name, (ENUM_OBJECT_PROPERTY_INTEGER)prop_id, 0, val))
      return 0;

   return (datetime)val;
}   
  
  
   
string FormatStrategyLabel(string strategyCode, string direction, int magic)
{
   return StringFormat("%s %s #%d", strategyCode, direction, magic);
}


// Funzione unica per log

void LogOrderPreview(string strategyCode, string direction, int magic)
{
   string label = FormatStrategyLabel(strategyCode, direction, magic);
   Print("[INFO] Opening ", label);
}



double CalculateTrendlineVelocity(string name) {
   long t1_raw, t2_raw;
   if (!ObjectGetInteger(0, name, OBJPROP_TIME, 0, t1_raw) ||
       !ObjectGetInteger(0, name, OBJPROP_TIME, 1, t2_raw))
       return 0.0;

   datetime t1 = (datetime)t1_raw;
   datetime t2 = (datetime)t2_raw;

   double p1 = ObjectGetDouble(0, name, OBJPROP_PRICE, 0);
   double p2 = ObjectGetDouble(0, name, OBJPROP_PRICE, 1);

   double delta_price = MathAbs(p2 - p1);
   double delta_time  = (double)(t2 - t1) / 60.0;

   if (delta_time == 0.0) return 0.0;
   return delta_price / delta_time / _Point;
}




void OnTick()
{
   static datetime last_exec = 0;
   if (TimeCurrent() == last_exec) return;
   last_exec = TimeCurrent();

   // === 1. CALCOLO LOTTO ===
   double lot = volume.CalculateLot(); // Usa il tuo VolumeManager
   
   
   
   
   //=== 1. MERCATO FAVOREVOLE? ===//
  if (!bypass_filter && !IsMarketFavorable()) return;

   //=== 2. AGGIORNA TRENDLINE ===//
   UpdateTrendline("Trendline0", micro_bars);
   UpdateTrendline("Trendline1", macro_bars);
   if (TimeCurrent() - last_extra_update >= extra_interval_sec) {
      UpdateTrendline("Trendline2", extra_bars);
      last_extra_update = TimeCurrent();
   }

   //=== 3. CALCOLA METRICHE ===//
 
   
   ApplyTrailingStop((int)inp_trail_pips);

   


   
   //=== 4. RACCOLTA DATI TRENDLINE ===//
   double a_micro = GetSlope("Trendline0");
   double a_macro = GetSlope("Trendline1");
   double a_extra = GetSlope("Trendline2");
   
      //=== [üìå BLOCCO 1 - Calcolo valori INDEX per Strategia 4] ===//
indexMicro = CalculateTrendlineVelocity("Trendline0");
indexMacro = CalculateTrendlineVelocity("Trendline1");
indexExtra = CalculateTrendlineVelocity("Trendline2");
   
   
   double dist     = (iClose(_Symbol, _Period, 0) - ObjectGetDouble(0, "Trendline2", OBJPROP_PRICE, 1)) / _Point;
   double delta_mm = MathAbs(a_macro - a_micro);
   double delta_me = MathAbs(a_macro - a_extra);
   double delta_em = MathAbs(a_extra - a_micro);
   int up      = CountUP(count_window);
   int down    = CountDOWN(count_window);
   int support = CountSUPPORT(count_window);
   decision.LoadData(a_micro, a_macro, a_extra, delta_mm, delta_me, delta_em, dist, up, down, support);
    
    
    
    //=== 6. VISUAL TRACK COUNTER ===//

// Array dinamici per visualizzazione
string names[];
double angles[], dirs[], speeds[], deltas[], volumes[];
int bars[];

ArrayResize(names, 3);
ArrayResize(angles, 3);
ArrayResize(dirs, 3);
ArrayResize(speeds, 3);
ArrayResize(deltas, 3);
ArrayResize(volumes, 3);
ArrayResize(bars, 3);

// Popolamento array con i valori reali
names[0] = "MICRO";  names[1] = "MACRO";  names[2] = "EXTRA";

angles[0] = a_micro; angles[1] = a_macro; angles[2] = a_extra;

dirs[0] = indexMicro; dirs[1] = indexMacro; dirs[2] = indexExtra;

speeds[0] = CalculateTrendlineVelocity("Trendline0");
speeds[1] = CalculateTrendlineVelocity("Trendline1");
speeds[2] = CalculateTrendlineVelocity("Trendline2");

bars[0] = TrendlineLengthBars("Trendline0");
bars[1] = TrendlineLengthBars("Trendline1");
bars[2] = TrendlineLengthBars("Trendline2");

deltas[0] = a_micro - a_macro;
deltas[1] = a_macro - a_extra;
deltas[2] = a_extra - a_micro;

// ‚ö†Ô∏è Placeholder per volume (modifica con dati reali se servono)
volumes[0] = 1.9;
volumes[1] = 2.3;
volumes[2] = 2.7;



// disegnatabella nuova

trackDrawer.ClearTrackCounter(); // ‚úÖ OK

trackDrawer.Draw(names, angles, dirs, speeds, bars, deltas, volumes); // ‚úÖ OK
    
    
  
    
  //=== 5. STRATEGIA 1 ===//
if (params.IsEnabled(S1) && !executor.HasOpenTrade(params.GetMagic(S1))) {
      if (params.UseBuy(S1) && decision.CheckCompressionBUY()) {
         string dir = params.IsInverted(S1) ? "SELL" : "BUY";
         string label = FormatStrategyLabel("S1", dir, params.GetMagic(S1));
         Print("[INFO] Opening ", label);
         if (dir == "BUY")
            executor.OpenBuy(lot, params.GetSL(S1), params.GetTP(S1), params.GetMagic(S1), label);
         else
            executor.OpenSell(lot, params.GetSL(S1), params.GetTP(S1), params.GetMagic(S1), label);
      }
      if (params.UseSell(S1) && decision.CheckCompressionSELL()) {
         string dir = params.IsInverted(S1) ? "BUY" : "SELL";
         string label = FormatStrategyLabel("S1", dir, params.GetMagic(S1));
         Print("[INFO] Opening ", label);
         if (dir == "BUY")
            executor.OpenBuy(lot, params.GetSL(S1), params.GetTP(S1), params.GetMagic(S1), label);
         else
            executor.OpenSell(lot, params.GetSL(S1), params.GetTP(S1), params.GetMagic(S1), label);
      }
   }

   //=== 6. STRATEGIA 2 ===//
if (params.IsEnabled(S2) && !executor.HasOpenTrade(params.GetMagic(S2))) {
   double v_micro = CalculateTrendlineVelocity("Trendline0");

   bool buySignal = decision.CheckContrarianCumulative(
      true, a_micro, a_macro, a_extra, v_micro, dist,
      angle_thresh_macro_s2_buy, angle_thresh_extra_s2_buy, angle_max_micro_s2_buy,
      velocity_min_micro_s2_buy, min_dist_extra_s2_buy
   );

   bool sellSignal = decision.CheckContrarianCumulative(
      false, a_micro, a_macro, a_extra, v_micro, dist,
      angle_thresh_macro_s2, angle_thresh_extra_s2, angle_min_micro_s2,
      velocity_min_micro_s2, min_dist_extra_s2
   );

   // BUY
   if (params.UseBuy(S2) && buySignal) {
      string dir = params.IsInverted(S2) ? "SELL" : "BUY";
      string label = FormatStrategyLabel("S2", dir, params.GetMagic(S2));
      Print("[INFO] Opening ", label);
      if (dir == "BUY")
         executor.OpenBuy(lot, params.GetSL(S2), params.GetTP(S2), params.GetMagic(S2), label);
      else
         executor.OpenSell(lot, params.GetSL(S2), params.GetTP(S2), params.GetMagic(S2), label);
   }

   // SELL
   if (params.UseSell(S2) && sellSignal) {
      string dir = params.IsInverted(S2) ? "BUY" : "SELL";
      string label = FormatStrategyLabel("S2", dir, params.GetMagic(S2));
      Print("[INFO] Opening ", label);
      if (dir == "BUY")
         executor.OpenBuy(lot, params.GetSL(S2), params.GetTP(S2), params.GetMagic(S2), label);
      else
         executor.OpenSell(lot, params.GetSL(S2), params.GetTP(S2), params.GetMagic(S2), label);
   }
}

//=== 7. STRATEGIA 3 ===//
if (params.IsEnabled(S3) && !executor.HasOpenTrade(params.GetMagic(S3))) {
   if (params.UseBuy(S3) && decision.CheckRetracementBUY()) {
      string dir = params.IsInverted(S3) ? "SELL" : "BUY";
      string label = FormatStrategyLabel("S3", dir, params.GetMagic(S3));
      Print("[INFO] Opening ", label);
      if (dir == "BUY")
         executor.OpenBuy(lot, params.GetSL(S3), params.GetTP(S3), params.GetMagic(S3), label);
      else
         executor.OpenSell(lot, params.GetSL(S3), params.GetTP(S3), params.GetMagic(S3), label);
   }

   if (params.UseSell(S3) && decision.CheckRetracementSELL()) {
      string dir = params.IsInverted(S3) ? "BUY" : "SELL";
      string label = FormatStrategyLabel("S3", dir, params.GetMagic(S3));
      Print("[INFO] Opening ", label);
      if (dir == "BUY")
         executor.OpenBuy(lot, params.GetSL(S3), params.GetTP(S3), params.GetMagic(S3), label);
      else
         executor.OpenSell(lot, params.GetSL(S3), params.GetTP(S3), params.GetMagic(S3), label);
   }
}

/*
   //=== 8. STRATEGIA 4 - Contrarian ciclico con trigger reversal ===//
if (params.IsEnabled(S4) && !executor.HasOpenTrade(params.GetMagic(S4))) {
      if (params.UseBuy(S4) && decision.CheckContrarianAuto(true, 
            params.Get("angle_thresh_extra", S4),
            params.Get("angle_thresh_macro", S4),
            params.Get("angle_min_micro", S4),
            params.Get("velocity_min_micro", S4),
            params.Get("min_dist_extra", S4))) {
         
         string dir = params.IsInverted(S4) ? "SELL" : "BUY";
         string label = FormatStrategyLabel("S4", dir, params.GetMagic(S4));
         Print("[INFO] Opening ", label);
         if (dir == "BUY")
            executor.OpenBuy(lot, params.GetSL(S4), params.GetTP(S4), params.GetMagic(S4), label);
         else
            executor.OpenSell(lot, params.GetSL(S4), params.GetTP(S4), params.GetMagic(S4), label);
      }

      if (params.UseSell(S4) && decision.CheckContrarianAuto(false, 
            params.Get("angle_thresh_extra", S4),
            params.Get("angle_thresh_macro", S4),
            params.Get("angle_min_micro", S4),
            params.Get("velocity_min_micro", S4),
            params.Get("min_dist_extra", S4))) {
         
         string dir = params.IsInverted(S4) ? "BUY" : "SELL";
         string label = FormatStrategyLabel("S4", dir, params.GetMagic(S4));
         Print("[INFO] Opening ", label);
         if (dir == "BUY")
            executor.OpenBuy(lot, params.GetSL(S4), params.GetTP(S4), params.GetMagic(S4), label);
         else
            executor.OpenSell(lot, params.GetSL(S4), params.GetTP(S4), params.GetMagic(S4), label);
      }
   }

*/


   }

bool CheckContrarianAuto(bool isBuy,
                         double angleMicro, double angleMacro, double angleExtra,
                         double distancePriceToExtra,
                         double idxMicro, double idxMacro, double idxExtra,
                         double thresholdDistanceBUY, double thresholdDistanceSELL,
                         double minIndexBuy, double maxIndexSell)
{
   if (isBuy)
   {
      return (
         angleMicro > 0 && angleMacro > 0 && angleExtra > 0 &&
         distancePriceToExtra > thresholdDistanceBUY &&
         idxMicro > minIndexBuy &&
         idxMacro > minIndexBuy &&
         idxExtra > minIndexBuy
      );
   }
   else
   {
      return (
         angleMicro < 0 && angleMacro < 0 && angleExtra < 0 &&
         distancePriceToExtra < thresholdDistanceSELL &&
         idxMicro < maxIndexSell &&
         idxMacro < maxIndexSell &&
         idxExtra < maxIndexSell
      );
   }
}
   

void ClosePositionByMagic(int magic) {
   for (int i = PositionsTotal() - 1; i >= 0; i--) {
      if (PositionGetTicket(i) == 0) continue;
      ulong ticket = PositionGetTicket(i);
      if (!PositionSelectByTicket(ticket)) continue;
      if ((int)PositionGetInteger(POSITION_MAGIC) == magic) {
         string symbol = PositionGetString(POSITION_SYMBOL);
         double volume = PositionGetDouble(POSITION_VOLUME);
         long type = PositionGetInteger(POSITION_TYPE);

         if (type == POSITION_TYPE_BUY)
            trade.PositionClose(symbol);
         else if (type == POSITION_TYPE_SELL)
            trade.PositionClose(symbol);
      }
   }
}





void UpdateTrendline(string name, int bars_back) {
    if(Bars(_Symbol,_Period)<bars_back) return;

    datetime t1 = iTime(_Symbol,_Period,bars_back);
    double p1 = GetPriceValue(bars_back, TL_CalcBase);  // sostituito iClose con GetPriceValue
    datetime t2 = iTime(_Symbol,_Period,0);
    double p2 = GetPriceValue(0, TL_CalcBase);          // sostituito iClose con GetPriceValue

    if(ObjectFind(0,name)<0)
        ObjectCreate(0,name,OBJ_TREND,0,t1,p1,t2,p2);
    else {
        ObjectMove(0,name,0,t1,p1);
        ObjectMove(0,name,1,t2,p2);
    }
    double angle = GetSlope(name);
    ObjectSetInteger(0,name,OBJPROP_COLOR,(angle>=0)?clrLime:clrRed);
    ObjectSetInteger(0,name,OBJPROP_WIDTH,StringToInteger(StringSubstr(name,-1))+1);
}


double GetSlope(string obj) {
    long t1_raw, t2_raw;
    if(!ObjectGetInteger(0, obj, OBJPROP_TIME, 0, t1_raw) ||
       !ObjectGetInteger(0, obj, OBJPROP_TIME, 1, t2_raw))
        return 0.0;
    datetime t1 = (datetime)t1_raw;
    datetime t2 = (datetime)t2_raw;
    double p1 = ObjectGetDouble(0, obj, OBJPROP_PRICE, 0);
    double p2 = ObjectGetDouble(0, obj, OBJPROP_PRICE, 1);
    double dx = (double)(t2 - t1) / 60.0;
    double dy = (p2 - p1) / _Point;
    double factor = 2.0;
    if(dx == 0.0) return 0.0;
    return MathArctan((dy / dx) * factor) * 180.0 / M_PI;
}

//+------------------------------------------------------------------+
//| NUOVA FUNZIONE: GetTrendRealStrength()                          |
//| Metodo: RGOLD - Strategia 4 (e futura estensione S1-S3)         |
//| Descrizione: calcola la "forza reale" di una trendline          |
//| sulla base dello scostamento diretto del prezzo e              |
//| dell‚Äôoscillazione interna tra punto A (inizio) e B (fine).      |
//+------------------------------------------------------------------+

// === PATCH PER STRENGTH REALE ===
double GetTrendRealStrength(string trendName) {
   datetime t1 = (datetime)ObjectGetInteger(0, trendName, OBJPROP_TIME, 0);
   datetime t2 = (datetime)ObjectGetInteger(0, trendName, OBJPROP_TIME, 1);
   double   p1 = ObjectGetDouble(0, trendName, OBJPROP_PRICE, 0);
   double   p2 = ObjectGetDouble(0, trendName, OBJPROP_PRICE, 1);
   int bars = TrendlineLengthBars(trendName);
   if (bars == 0) return 0.0;
   double scostamento = MathAbs(p2 - p1);
   return scostamento / bars / _Point;
}

int TrendlineLengthBars(string trendName) {
   datetime t1 = (datetime)ObjectGetInteger(0, trendName, OBJPROP_TIME, 0);
   datetime t2 = (datetime)ObjectGetInteger(0, trendName, OBJPROP_TIME, 1);
   return Bars(_Symbol, _Period, t1, t2);
}

//+------------------------------------------------------------------+
//| NOTE:                                                           |
//| Valori vicini a 1 ‚Üí trend forte e coerente                      |
//| Valori < 0.3 ‚Üí oscillazioni laterali o poco direzionali        |
//| Valori 0 ‚Üí anomalia o barra piatta                             |
//+------------------------------------------------------------------+


// === PATCH PER CALCULATEMETRICS ===
void CalculateMetrics() {
    double a0 = GetSlope("Trendline0");
    double a1 = GetSlope("Trendline1");
    double a2 = GetSlope("Trendline2");

    double v0 = CalculateTrendlineVelocity("Trendline0");
    double v1 = CalculateTrendlineVelocity("Trendline1");
    double v2 = CalculateTrendlineVelocity("Trendline2");

    // ‚úÖ Nuovi valori di forza direzionale realistica
    double f0 = GetTrendRealStrength("Trendline0");  // MICRO
    double f1 = GetTrendRealStrength("Trendline1");  // MACRO
    double f2 = GetTrendRealStrength("Trendline2");  // EXTRA

    double dist = (iClose(_Symbol,_Period,0)-ObjectGetDouble(0,"Trendline2",OBJPROP_PRICE,1))/_Point;

    

    // === TRACK COUNTER - Nuova tabella forza trend (logica grezza temporanea su LabelLeft_Lengths)
    string line = 
      "EXTRA: " + StringFormat("Idx: %.2f | %.1f¬∞ | %.2fpt/min | Bars: %d", f2, a2, v2, TrendlineLengthBars("Trendline2")) + "\n" +
      "MACRO: " + StringFormat("Idx: %.2f | %.1f¬∞ | %.2fpt/min | Bars: %d", f1, a1, v1, TrendlineLengthBars("Trendline1")) + "\n" +
      "MICRO: " + StringFormat("Idx: %.2f | %.1f¬∞ | %.2fpt/min | Bars: %d", f0, a0, v0, TrendlineLengthBars("Trendline0"));

    
}





int CountUP(int window) {
    int count = 0;
    for(int i=1; i<=window; i++) {
        double ma = GetSlope("Trendline1");
        double mi = GetSlope("Trendline0");
        if(mi > ma) count++;
    }
    return count;
}

int CountDOWN(int window) {
    int count = 0;
    for(int i=1; i<=window; i++) {
        double ma = GetSlope("Trendline1");
        double mi = GetSlope("Trendline0");
        if(mi < ma) count++;
    }
    return count;
}

int CountSUPPORT(int window) {
    int count = 0;
    for(int i=1; i<=window; i++) {
        double a0 = GetSlope("Trendline0");
        double a1 = GetSlope("Trendline1");
        double a2 = GetSlope("Trendline2");
        if((a0 > 0 && a1 > 0 && a2 > 0) || (a0 < 0 && a1 < 0 && a2 < 0))
            count++;
    }
    return count;
}

double GetMomentumCurrentTF() {
    double open = iOpen(_Symbol, _Period, 0);
    double close = iClose(_Symbol, _Period, 0);
    return MathAbs(close - open) / _Point;
}

double NormalizeMomentum(double momentum) {
    return MathMin(inp_momentum_max_factor, MathMax(inp_momentum_min_factor, momentum / inp_momentum_base));
}



void ApplyTrailingStop(int trailPips) {
   if (PositionsTotal() == 0) return;

   double momentum = GetMomentumCurrentTF();
   double factor = NormalizeMomentum(momentum);
   double adjustedTrail = trailPips / factor;

   // Ciclo sulle posizioni aperte
for (int i = 0; i < PositionsTotal(); i++) {
   ulong ticket = PositionGetTicket(i);
   if (!PositionSelectByTicket(ticket)) continue;

   string symbol = PositionGetString(POSITION_SYMBOL);
   long type = PositionGetInteger(POSITION_TYPE);
   double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);

   double open = PositionGetDouble(POSITION_PRICE_OPEN);
   double sl = PositionGetDouble(POSITION_SL);
   double tp = PositionGetDouble(POSITION_TP);

   // Prezzo attuale
   double price = (type == POSITION_TYPE_BUY)
                  ? SymbolInfoDouble(symbol, SYMBOL_BID)
                  : SymbolInfoDouble(symbol, SYMBOL_ASK);

   // Profitto in punti, non in valuta
   double profit_points = MathAbs(price - open) / point;

   // === FILTRO 1: profitto minimo prima del trailing dinamico
   if (profit_points < inp_profit_trigger_points) {
      Print("‚è∏Ô∏è Trailing bloccato: profitto attuale ", profit_points,
            "pt < soglia ", inp_profit_trigger_points, "pt");
      continue;
   }

   // === FILTRO 2: spike eccessivo nella candela corrente
   double candle_spike = iHigh(symbol, _Period, 0) - iLow(symbol, _Period, 0);
   if (candle_spike > inp_spike_threshold_points * point) {
      Print("‚ö†Ô∏è Spike rilevato nella candela: ", candle_spike / point,
            "pt > soglia ", inp_spike_threshold_points, "pt");
      continue;
   }

   // === Calcolo trailing dinamico basato su momentum
   double momentum = GetMomentumCurrentTF();
   double factor = NormalizeMomentum(momentum);
   double adjustedTrail = inp_trail_pips / factor;

   // === Nuovo SL calcolato
   double new_sl;
   if (type == POSITION_TYPE_BUY) {
      new_sl = NormalizeDouble(price - adjustedTrail * point, digits);
      if (sl < new_sl)
         executor.ModifyPosition(ticket, new_sl, tp);
   }
   else if (type == POSITION_TYPE_SELL) {
      new_sl = NormalizeDouble(price + adjustedTrail * point, digits);
      if (sl > new_sl || sl == 0.0)
         executor.ModifyPosition(ticket, new_sl, tp);
   }
   
   string lengths = StringFormat("LenMic: %d | LenMac: %d | LenExt: %d",
   TrendlineLengthBars("Trendline0"),
   TrendlineLengthBars("Trendline1"),
   TrendlineLengthBars("Trendline2"));

ObjectSetString(0, "LabelLeft5", OBJPROP_TEXT, lengths);

   // Audit opzionale
   AuditCheck::CheckTrailingLogic(profit_points, momentum, inp_profit_trigger_points, inp_momentum_base);
}
}

